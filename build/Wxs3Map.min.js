var Wxs3Map =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	var _ThreeDMapUntiled = __webpack_require__(2);
	
	var _ThreeDMapUntiled2 = _interopRequireDefault(_ThreeDMapUntiled);
	
	var _Texture = __webpack_require__(14);
	
	var _Texture2 = _interopRequireDefault(_Texture);
	
	var _Terrain = __webpack_require__(15);
	
	var _Terrain2 = _interopRequireDefault(_Terrain);
	
	var _Profiles = __webpack_require__(16);
	
	var _Profiles2 = _interopRequireDefault(_Profiles);
	
	var _Envelope = __webpack_require__(17);
	
	var _Envelope2 = _interopRequireDefault(_Envelope);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var defaults = {
	    div: 'map',
	    bbox: '7.856598,62.333035,8.583069,62.559503',
	    bboxCrs: 'EPSG:4326',
	    wireframe: false,
	    zMult: 1,
	    zInv: false,
	    crs: 'EPSG:32633',
	    texture: {
	        type: 'wms',
	        wmsUrl: 'http://openwms.statkart.no/skwms1/wms.topo2',
	        wmsLayers: 'topo2_WMS',
	        wmsFormat: 'image/png',
	        wmsFormatMode: ''
	    },
	    terrain: {
	        pixelsPerVertex: 8, //the resolution of the height model in the image
	        wcsUrl: 'http://wms.geonorge.no/skwms1/wcs.dtm',
	        wcsResolution: 10, //resolution of grid cell in meters
	        coverage: 'land_utm33_10m',
	        format: 'geotiff',
	        showBox: true,
	        boxColor: 0xdddddd
	    },
	    profiles: null
	};
	
	function extendDefaults(config) {
	    var texture = _.extend({}, defaults.texture, config.texture || {});
	    var terrain = _.extend({}, defaults.terrain, config.terrain || {});
	    var confExtended = _.extend({}, defaults, config);
	    confExtended.texture = texture;
	    confExtended.terrain = terrain;
	    return confExtended;
	};
	
	function Dimensions(config) {
	
	    var div = document.getElementById(config.div);
	    var width = div.clientWidth;
	    var height = div.clientHeight;
	
	    var envelope = (0, _Envelope2.default)(config.bbox, config.crs, config.bboxCrs);
	
	    var metersWidth = envelope.width();
	    var metersHeight = envelope.height();
	
	    //Adjust output image to canvas if not specified
	    var imgWidth, imgHeight;
	    if (!config.texture.imgWidth || !config.texture.imgHeight) {
	        var imgCoefficient = metersWidth / metersHeight;
	        if (width / height < imgCoefficient) {
	            imgWidth = width;
	            imgHeight = Math.round(imgWidth / imgCoefficient);
	        } else {
	            imgHeight = height;
	            imgWidth = Math.round(imgHeight * imgCoefficient);
	        }
	    } else {
	        imgWidth = config.texture.imgWidth;
	        imgHeight = config.texture.imgHeight;
	    }
	
	    //Compute the resolution of the height model in the image (pixelsPerVertex)
	    var demWidth = Math.round(imgWidth / config.terrain.pixelsPerVertex);
	    var demHeight = Math.round(imgHeight / config.terrain.pixelsPerVertex);
	
	    if (demWidth > metersWidth / config.terrain.wcsResolution) {
	        //ajust to avoid stairs in the model - reduce dem to actual resolution
	        demWidth = Math.round(metersWidth / config.terrain.wcsResolution);
	        demHeight = Math.round(metersHeight / config.terrain.wcsResolution);
	    }
	
	    // mapunits between vertexes in x-dimention
	    var proportionWidth = metersWidth / demWidth;
	
	    // mapunits between vertexes in y-dimention
	    var proportionHeight = metersHeight / demHeight;
	
	    // average mapunits between vertexes
	    var proportionAverage = (proportionWidth + proportionHeight) / 2;
	
	    if (config.zInv) {
	        proportionAverage = proportionAverage * -1;
	    }
	    var zMult;
	    if (config.zMult) {
	        zMult = proportionAverage / config.zMult;
	    } else {
	        zMult = proportionAverage;
	    }
	
	    return {
	        config: config,
	        div: div,
	        envelope: envelope,
	        width: width,
	        height: height,
	        imgWidth: imgWidth,
	        imgHeight: imgHeight,
	        demWidth: demWidth,
	        demHeight: demHeight,
	        zMult: zMult,
	        crs: config.crs
	    };
	}
	
	function Wxs3Map(config) {
	    config = extendDefaults(config || {});
	    var dimensions = Dimensions(config);
	    var texture = (0, _Texture2.default)(config.texture, dimensions);
	    var terrain = (0, _Terrain2.default)(config.terrain, dimensions);
	    var profiles;
	    if (config.profiles) {
	        profiles = (0, _Profiles2.default)(config.profiles, terrain, dimensions);
	    }
	    return new _ThreeDMapUntiled2.default(dimensions, terrain, texture, profiles);
	}
	
	window.Wxs3Map = Wxs3Map;
	
	exports.default = Wxs3Map;

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = _;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(3);
	
	var _three2 = __webpack_require__(4);
	
	var _three3 = _interopRequireDefault(_three2);
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	var _tiff = __webpack_require__(5);
	
	var _tiff2 = _interopRequireDefault(_tiff);
	
	var _createQueryString = __webpack_require__(6);
	
	var _createQueryString2 = _interopRequireDefault(_createQueryString);
	
	var _events = __webpack_require__(7);
	
	var _events2 = _interopRequireDefault(_events);
	
	var _Line = __webpack_require__(8);
	
	var _Line2 = _interopRequireDefault(_Line);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ThreeDMapUntiled = function ThreeDMapUntiled(dim, terrain, texture, profiles) {
	    this.dim = dim;
	    this.terrain = terrain;
	    this.texture = texture;
	    this.profiles = profiles;
	    this.events = (0, _events2.default)();
	
	    this.reloadTimer = -1;
	
	    this.linesToClamp = [];
	
	    this._renderer = this._createRenderer();
	    this._camera = this._createCamera();
	    this._controls = this._createControls();
	    this._material = this._createMaterial();
	
	    //Create Mesh and Scene
	    var mesh = this._createMesh();
	    this._scene = this._createScene(mesh);
	
	    //Add webgl canvas to div
	    this.dim.div.appendChild(this._renderer.domElement);
	
	    //Start renderer and listen to changes in geometry
	    this._render();
	
	    //Load height model and texture asynchronously
	    this.events.fire('onTerrainLoadStart');
	    this.terrain.loadTerrain(this._terrainLoaded.bind(this));
	
	    this.events.fire('onTextureLoadStart');
	    this.texture.loadTexture(this._material, this._textureLoaded.bind(this));
	
	    //Adust canvas if container is resized
	    window.addEventListener('resize', this._resizeMe.bind(this), false);
	    this.on('onTerrainLoadEnd', this._clampLines, this);
	};
	
	ThreeDMapUntiled.prototype.on = function (event, callback, context) {
	    this.events.on(event, callback, context);
	};
	
	ThreeDMapUntiled.prototype._terrainLoaded = function () {
	    this.events.fire('onTerrainLoadEnd');
	    this._scene.add(this.terrain.getSides());
	
	    if (this.profiles) {
	        this.profiles.load(this._profilesLoaded.bind(this));
	    }
	};
	
	ThreeDMapUntiled.prototype._profilesLoaded = function (meshes) {
	    _.each(meshes, function (mesh) {
	        this._scene.add(mesh);
	    }, this);
	};
	
	ThreeDMapUntiled.prototype._textureLoaded = function (texture) {
	    this.events.fire('onTextureLoadEnd');
	};
	
	ThreeDMapUntiled.prototype._createRenderer = function () {
	    var renderer = new _three.WebGLRenderer({
	        alpha: true
	    });
	    renderer.setSize(this.dim.width, this.dim.height);
	    return renderer;
	};
	
	ThreeDMapUntiled.prototype._createScene = function (mesh) {
	    var scene = new _three.Scene();
	
	    //Ambient Light for MeshPhongMaterial
	    scene.add(new _three.AmbientLight(0xffffff));
	    scene.add(mesh);
	
	    return scene;
	};
	
	ThreeDMapUntiled.prototype._createCamera = function () {
	    var fov = 45,
	        cameraHeight;
	
	    var camera = new _three.PerspectiveCamera(fov, this.dim.width / this.dim.height, 0.1, 1000);
	
	    // Some trig to find height for camera
	    if (!!this.dim.Z) {
	        cameraHeight = this.dim.Z;
	    } else {
	        //Adapt optimal side length according to canvas
	        var sideLength;
	        var canvCoefficient = this.dim.width / this.dim.height;
	        if (canvCoefficient < this.dim.demWidth / this.dim.demHeight) {
	            sideLength = this.dim.demWidth / canvCoefficient;
	        } else {
	            sideLength = this.dim.demHeight;
	        }
	
	        //calculate camera height
	        cameraHeight = sideLength / 2 / Math.tan(fov / 2 * Math.PI / 180);
	    }
	
	    camera.position.set(0, 0, cameraHeight);
	    return camera;
	};
	
	ThreeDMapUntiled.prototype._createMaterial = function () {
	    var material = new _three.MeshPhongMaterial({ //for shading and Ambient Light
	        side: this.terrain.showBox ? _three.FrontSide : _three.DoubleSide
	    });
	    material.wireframe = this.dim.wireframe;
	    return material;
	};
	
	ThreeDMapUntiled.prototype._createMesh = function () {
	    return new _three.Mesh(this.terrain.getGeometry(), this._material);
	};
	
	ThreeDMapUntiled.prototype._createControls = function () {
	    return new _three3.default(this._camera);
	};
	
	ThreeDMapUntiled.prototype._render = function () {
	    this._controls.update();
	    window.requestAnimationFrame(this._render.bind(this));
	    this._renderer.render(this._scene, this._camera);
	};
	
	ThreeDMapUntiled.prototype._resizeMe = function () {
	    window.clearTimeout(this.reloadTimer);
	    this.reloadTimer = window.setTimeout(this._reloadAll.bind(this), 1000);
	    return;
	};
	
	ThreeDMapUntiled.prototype._reloadAll = function () {
	    this.dim.width = this.dim.div.clientWidth;
	    this.dim.height = this.dim.div.clientHeight;
	
	    this._camera.aspect = this.dim.width / this.dim.height;
	    this._camera.updateProjectionMatrix();
	
	    delete this._controls;
	    this._controls = this._createControls();
	    this._renderer.setSize(this.dim.width, this.dim.height);
	};
	
	ThreeDMapUntiled.prototype.addLine = function (lineGeom, lineStyle) {
	    var line = (0, _Line2.default)(lineGeom, lineStyle, this.terrain.getGeometry(), this.dim.envelope);
	    var threeLine = line.getThreeLine();
	    this._scene.add(threeLine);
	    if (line.needsClamp()) {
	        this.linesToClamp.push(line);
	    }
	};
	
	ThreeDMapUntiled.prototype._clampLines = function () {
	    _.each(this.linesToClamp, function (line) {
	        var oldLine = line.getThreeLine();
	        var clamped = line.clamp();
	        this._scene.remove(oldLine);
	        this._scene.add(clamped);
	    }, this);
	    this.linesToClamp = [];
	};
	
	exports.default = ThreeDMapUntiled;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = THREE;

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = TrackballControls;

/***/ },
/* 5 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	
	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	function TIFFParser() {
		this.tiffDataView = undefined;
		this.littleEndian = undefined;
		this.fileDirectories = [];
	};
	
	TIFFParser.prototype = {
		isLittleEndian: function isLittleEndian() {
			// Get byte order mark.
			var BOM = this.getBytes(2, 0);
	
			// Find out the endianness.
			if (BOM === 0x4949) {
				this.littleEndian = true;
			} else if (BOM === 0x4D4D) {
				this.littleEndian = false;
			} else {
				console.log(BOM);
				throw TypeError("Invalid byte order value.");
			}
	
			return this.littleEndian;
		},
	
		hasTowel: function hasTowel() {
			// Check for towel.
			if (this.getBytes(2, 2) !== 42) {
				throw RangeError("You forgot your towel!");
				return false;
			}
	
			return true;
		},
	
		getFieldTagName: function getFieldTagName(fieldTag) {
			// See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf
			// See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml
			var fieldTagNames = {
				// TIFF Baseline
				0x013B: 'Artist',
				0x0102: 'BitsPerSample',
				0x0109: 'CellLength',
				0x0108: 'CellWidth',
				0x0140: 'ColorMap',
				0x0103: 'Compression',
				0x8298: 'Copyright',
				0x0132: 'DateTime',
				0x0152: 'ExtraSamples',
				0x010A: 'FillOrder',
				0x0121: 'FreeByteCounts',
				0x0120: 'FreeOffsets',
				0x0123: 'GrayResponseCurve',
				0x0122: 'GrayResponseUnit',
				0x013C: 'HostComputer',
				0x010E: 'ImageDescription',
				0x0101: 'ImageLength',
				0x0100: 'ImageWidth',
				0x010F: 'Make',
				0x0119: 'MaxSampleValue',
				0x0118: 'MinSampleValue',
				0x0110: 'Model',
				0x00FE: 'NewSubfileType',
				0x0112: 'Orientation',
				0x0106: 'PhotometricInterpretation',
				0x011C: 'PlanarConfiguration',
				0x0128: 'ResolutionUnit',
				0x0116: 'RowsPerStrip',
				0x0115: 'SamplesPerPixel',
				0x0131: 'Software',
				0x0117: 'StripByteCounts',
				0x0111: 'StripOffsets',
				0x00FF: 'SubfileType',
				0x0107: 'Threshholding',
				0x011A: 'XResolution',
				0x011B: 'YResolution',
	
				// TIFF Extended
				0x0146: 'BadFaxLines',
				0x0147: 'CleanFaxData',
				0x0157: 'ClipPath',
				0x0148: 'ConsecutiveBadFaxLines',
				0x01B1: 'Decode',
				0x01B2: 'DefaultImageColor',
				0x010D: 'DocumentName',
				0x0150: 'DotRange',
				0x0141: 'HalftoneHints',
				0x015A: 'Indexed',
				0x015B: 'JPEGTables',
				0x011D: 'PageName',
				0x0129: 'PageNumber',
				0x013D: 'Predictor',
				0x013F: 'PrimaryChromaticities',
				0x0214: 'ReferenceBlackWhite',
				0x0153: 'SampleFormat',
				0x022F: 'StripRowCounts',
				0x014A: 'SubIFDs',
				0x0124: 'T4Options',
				0x0125: 'T6Options',
				0x0145: 'TileByteCounts',
				0x0143: 'TileLength',
				0x0144: 'TileOffsets',
				0x0142: 'TileWidth',
				0x012D: 'TransferFunction',
				0x013E: 'WhitePoint',
				0x0158: 'XClipPathUnits',
				0x011E: 'XPosition',
				0x0211: 'YCbCrCoefficients',
				0x0213: 'YCbCrPositioning',
				0x0212: 'YCbCrSubSampling',
				0x0159: 'YClipPathUnits',
				0x011F: 'YPosition',
	
				// EXIF
				0x9202: 'ApertureValue',
				0xA001: 'ColorSpace',
				0x9004: 'DateTimeDigitized',
				0x9003: 'DateTimeOriginal',
				0x8769: 'Exif IFD',
				0x9000: 'ExifVersion',
				0x829A: 'ExposureTime',
				0xA300: 'FileSource',
				0x9209: 'Flash',
				0xA000: 'FlashpixVersion',
				0x829D: 'FNumber',
				0xA420: 'ImageUniqueID',
				0x9208: 'LightSource',
				0x927C: 'MakerNote',
				0x9201: 'ShutterSpeedValue',
				0x9286: 'UserComment',
	
				// IPTC
				0x83BB: 'IPTC',
	
				// ICC
				0x8773: 'ICC Profile',
	
				// XMP
				0x02BC: 'XMP',
	
				// GDAL
				0xA480: 'GDAL_METADATA',
				0xA481: 'GDAL_NODATA',
	
				// Photoshop
				0x8649: 'Photoshop'
			};
	
			var fieldTagName;
	
			if (fieldTag in fieldTagNames) {
				fieldTagName = fieldTagNames[fieldTag];
			} else {
				//console.log( "Unknown Field Tag:", fieldTag);
				fieldTagName = "Tag" + fieldTag;
			}
	
			return fieldTagName;
		},
	
		getFieldTypeName: function getFieldTypeName(fieldType) {
			var fieldTypeNames = {
				0x0001: 'BYTE',
				0x0002: 'ASCII',
				0x0003: 'SHORT',
				0x0004: 'LONG',
				0x0005: 'RATIONAL',
				0x0006: 'SBYTE',
				0x0007: 'UNDEFINED',
				0x0008: 'SSHORT',
				0x0009: 'SLONG',
				0x000A: 'SRATIONAL',
				0x000B: 'FLOAT',
				0x000C: 'DOUBLE'
			};
	
			var fieldTypeName;
	
			if (fieldType in fieldTypeNames) {
				fieldTypeName = fieldTypeNames[fieldType];
			}
	
			return fieldTypeName;
		},
	
		getFieldTypeLength: function getFieldTypeLength(fieldTypeName) {
			var fieldTypeLength;
	
			if (['BYTE', 'ASCII', 'SBYTE', 'UNDEFINED'].indexOf(fieldTypeName) !== -1) {
				fieldTypeLength = 1;
			} else if (['SHORT', 'SSHORT'].indexOf(fieldTypeName) !== -1) {
				fieldTypeLength = 2;
			} else if (['LONG', 'SLONG', 'FLOAT'].indexOf(fieldTypeName) !== -1) {
				fieldTypeLength = 4;
			} else if (['RATIONAL', 'SRATIONAL', 'DOUBLE'].indexOf(fieldTypeName) !== -1) {
				fieldTypeLength = 8;
			}
	
			return fieldTypeLength;
		},
	
		getBits: function getBits(numBits, byteOffset, bitOffset) {
			bitOffset = bitOffset || 0;
			var extraBytes = Math.floor(bitOffset / 8);
			var newByteOffset = byteOffset + extraBytes;
			var totalBits = bitOffset + numBits;
			var shiftRight = 32 - numBits;
	
			if (totalBits <= 0) {
				console.log(numBits, byteOffset, bitOffset);
				throw RangeError("No bits requested");
			} else if (totalBits <= 8) {
				var shiftLeft = 24 + bitOffset;
				var rawBits = this.tiffDataView.getUint8(newByteOffset, this.littleEndian);
			} else if (totalBits <= 16) {
				var shiftLeft = 16 + bitOffset;
				var rawBits = this.tiffDataView.getUint16(newByteOffset, this.littleEndian);
			} else if (totalBits <= 32) {
				var shiftLeft = bitOffset;
				var rawBits = this.tiffDataView.getUint32(newByteOffset, this.littleEndian);
			} else {
				console.log(numBits, byteOffset, bitOffset);
				throw RangeError("Too many bits requested");
			}
	
			var chunkInfo = {
				'bits': rawBits << shiftLeft >>> shiftRight,
				'byteOffset': newByteOffset + Math.floor(totalBits / 8),
				'bitOffset': totalBits % 8
			};
	
			return chunkInfo;
		},
	
		getBytes: function getBytes(numBytes, offset) {
			if (numBytes <= 0) {
				console.log(numBytes, offset);
				throw RangeError("No bytes requested");
			} else if (numBytes <= 1) {
				return this.tiffDataView.getUint8(offset, this.littleEndian);
			} else if (numBytes <= 2) {
				return this.tiffDataView.getUint16(offset, this.littleEndian);
			} else if (numBytes <= 3) {
				return this.tiffDataView.getUint32(offset, this.littleEndian) >>> 8;
			} else if (numBytes <= 4) {
				return this.tiffDataView.getUint32(offset, this.littleEndian);
				//return this.tiffDataView.getFloat32(offset, this.littleEndian);
			} else {
				console.log(numBytes, offset);
				throw RangeError("Too many bytes requested");
			}
		},
	
		getFieldValues: function getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {
			var fieldValues = [];
	
			var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
			var fieldValueSize = fieldTypeLength * typeCount;
	
			if (fieldValueSize <= 4) {
				// The value is stored at the big end of the valueOffset.
				if (this.littleEndian === false) {
					var value = valueOffset >>> (4 - fieldTypeLength) * 8;
				} else {
					var value = valueOffset;
				}
	
				fieldValues.push(value);
			} else {
				for (var i = 0; i < typeCount; i++) {
					var indexOffset = fieldTypeLength * i;
	
					if (fieldTypeLength >= 8) {
						if (['RATIONAL', 'SRATIONAL'].indexOf(fieldTypeName) !== -1) {
							// Numerator
							fieldValues.push(this.getBytes(4, valueOffset + indexOffset));
							// Denominator
							fieldValues.push(this.getBytes(4, valueOffset + indexOffset + 4));
						} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {
							fieldValues.push(this.getBytes(4, valueOffset + indexOffset) + this.getBytes(4, valueOffset + indexOffset + 4));
						} else {
							console.log(fieldTypeName, typeCount, fieldValueSize);
							throw TypeError("Can't handle this field type or size");
						}
					} else {
						fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
					}
				}
			}
	
			if (fieldTypeName === 'ASCII') {
				fieldValues.forEach(function (e, i, a) {
					a[i] = String.fromCharCode(e);
				});
			}
	
			return fieldValues;
		},
	
		clampColorSample: function clampColorSample(colorSample, bitsPerSample) {
			var multiplier = Math.pow(2, 8 - bitsPerSample);
	
			return Math.floor(colorSample * multiplier + (multiplier - 1));
		},
	
		makeRGBAFillValue: function makeRGBAFillValue(r, g, b, a) {
			if (typeof a === 'undefined') {
				a = 1.0;
			}
			return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
		},
	
		parseFileDirectory: function parseFileDirectory(byteOffset) {
			var numDirEntries = this.getBytes(2, byteOffset);
	
			var tiffFields = [];
	
			for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {
				var fieldTag = this.getBytes(2, i);
				var fieldType = this.getBytes(2, i + 2);
				var typeCount = this.getBytes(4, i + 4);
				var valueOffset = this.getBytes(4, i + 8);
	
				var fieldTagName = this.getFieldTagName(fieldTag);
				var fieldTypeName = this.getFieldTypeName(fieldType);
	
				var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
	
				tiffFields[fieldTagName] = { 'type': fieldTypeName, 'values': fieldValues };
			}
	
			this.fileDirectories.push(tiffFields);
	
			var nextIFDByteOffset = this.getBytes(4, i);
	
			if (nextIFDByteOffset === 0x00000000) {
				return this.fileDirectories;
			} else {
				return this.parseFileDirectory(nextIFDByteOffset);
			}
		},
	
		parseTIFF: function parseTIFF(tiffArrayBuffer, canvas) {
			canvas = canvas || document.createElement('canvas');
	
			this.tiffDataView = new DataView(tiffArrayBuffer);
			this.canvas = canvas;
	
			this.littleEndian = this.isLittleEndian(this.tiffDataView);
	
			if (!this.hasTowel(this.tiffDataView, this.littleEndian)) {
				return;
			}
	
			var firstIFDByteOffset = this.getBytes(4, 4);
	
			this.fileDirectories = this.parseFileDirectory(firstIFDByteOffset);
	
			var fileDirectory = this.fileDirectories[0];
	
			//console.log( fileDirectory );
	
			var imageWidth = fileDirectory.ImageWidth.values[0];
			var imageLength = fileDirectory.ImageLength.values[0];
	
			this.canvas.width = imageWidth;
			this.canvas.height = imageLength;
	
			var strips = [];
	
			var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;
	
			var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];
	
			var sampleProperties = [];
	
			var bitsPerPixel = 0;
			var hasBytesPerPixel = false;
	
			fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {
				sampleProperties[i] = {
					'bitsPerSample': bitsPerSample,
					'hasBytesPerSample': false,
					'bytesPerSample': undefined
				};
	
				if (bitsPerSample % 8 === 0) {
					sampleProperties[i].hasBytesPerSample = true;
					sampleProperties[i].bytesPerSample = bitsPerSample / 8;
				}
	
				bitsPerPixel += bitsPerSample;
			}, this);
	
			if (bitsPerPixel % 8 === 0) {
				hasBytesPerPixel = true;
				var bytesPerPixel = bitsPerPixel / 8;
			}
	
			var stripOffsetValues = fileDirectory.StripOffsets.values;
			var numStripOffsetValues = stripOffsetValues.length;
	
			// StripByteCounts is supposed to be required, but see if we can recover anyway.
			if (fileDirectory.StripByteCounts) {
				var stripByteCountValues = fileDirectory.StripByteCounts.values;
			} else {
				console.log("Missing StripByteCounts!");
	
				// Infer StripByteCounts, if possible.
				if (numStripOffsetValues === 1) {
					var stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];
				} else {
					throw Error("Cannot recover from missing StripByteCounts");
				}
			}
	
			// Loop through strips and decompress as necessary.
			for (var i = 0; i < numStripOffsetValues; i++) {
				var stripOffset = stripOffsetValues[i];
				strips[i] = [];
	
				var stripByteCount = stripByteCountValues[i];
	
				// Loop through pixels.
				for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
					// Decompress strip.
					switch (compression) {
						// Uncompressed
						case 1:
							// Loop through samples (sub-pixels).
							for (var m = 0, pixel = []; m < samplesPerPixel; m++) {
								if (sampleProperties[m].hasBytesPerSample) {
									// XXX: This is wrong!
									var sampleOffset = sampleProperties[m].bytesPerSample * m;
	
									//pixel.push(this.getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));
									pixel.push(this.tiffDataView.getFloat32(stripOffset + byteOffset + sampleOffset, this.littleEndian));
								} else {
									var sampleInfo = this.getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
	
									pixel.push(sampleInfo.bits);
	
									byteOffset = sampleInfo.byteOffset - stripOffset;
									bitOffset = sampleInfo.bitOffset;
	
									throw RangeError("Cannot handle sub-byte bits per sample");
								}
							}
	
							strips[i].push(pixel);
	
							if (hasBytesPerPixel) {
								jIncrement = bytesPerPixel;
							} else {
								jIncrement = 0;
	
								throw RangeError("Cannot handle sub-byte bits per pixel");
							}
							break;
	
						// CITT Group 3 1-Dimensional Modified Huffman run-length encoding
						case 2:
							// XXX: Use PDF.js code?
							break;
	
						// Group 3 Fax
						case 3:
							// XXX: Use PDF.js code?
							break;
	
						// Group 4 Fax
						case 4:
							// XXX: Use PDF.js code?
							break;
	
						// LZW
						case 5:
							// XXX: Use PDF.js code?
							break;
	
						// Old-style JPEG (TIFF 6.0)
						case 6:
							// XXX: Use PDF.js code?
							break;
	
						// New-style JPEG (TIFF Specification Supplement 2)
						case 7:
							// XXX: Use PDF.js code?
							break;
	
						// PackBits
						case 32773:
							// Are we ready for a new block?
							if (getHeader) {
								getHeader = false;
	
								var blockLength = 1;
								var iterations = 1;
	
								// The header byte is signed.
								var header = this.tiffDataView.getInt8(stripOffset + byteOffset, this.littleEndian);
	
								if (header >= 0 && header <= 127) {
									// Normal pixels.
									blockLength = header + 1;
								} else if (header >= -127 && header <= -1) {
									// Collapsed pixels.
									iterations = -header + 1;
								} else /*if (header === -128)*/{
										// Placeholder byte?
										getHeader = true;
									}
							} else {
								var currentByte = this.getBytes(1, stripOffset + byteOffset);
	
								// Duplicate bytes, if necessary.
								for (var m = 0; m < iterations; m++) {
									if (sampleProperties[sample].hasBytesPerSample) {
										// We're reading one byte at a time, so we need to handle multi-byte samples.
										currentSample = currentSample << 8 * numBytes | currentByte;
										numBytes++;
	
										// Is our sample complete?
										if (numBytes === sampleProperties[sample].bytesPerSample) {
											pixel.push(currentSample);
											currentSample = numBytes = 0;
											sample++;
										}
									} else {
										throw RangeError("Cannot handle sub-byte bits per sample");
									}
	
									// Is our pixel complete?
									if (sample === samplesPerPixel) {
										strips[i].push(pixel);
	
										pixel = [];
										sample = 0;
									}
								}
	
								blockLength--;
	
								// Is our block complete?
								if (blockLength === 0) {
									getHeader = true;
								}
							}
	
							jIncrement = 1;
							break;
	
						// Unknown compression algorithm
						default:
							// Do not attempt to parse the image data.
							break;
					}
				}
	
				//			console.log( strips[i] );
			}
	
			//console.log( strips );
			return strips;
	
			if (canvas.getContext) {
				var ctx = this.canvas.getContext("2d");
	
				// Set a default fill style.
				ctx.fillStyle = this.makeRGBAFillValue(255, 255, 255, 0);
	
				// If RowsPerStrip is missing, the whole image is in one strip.
				if (fileDirectory.RowsPerStrip) {
					var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];
				} else {
					var rowsPerStrip = imageLength;
				}
	
				var numStrips = strips.length;
	
				var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
				var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
	
				var numRowsInStrip = rowsPerStrip;
				var numRowsInPreviousStrip = 0;
	
				var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];
	
				var extraSamplesValues = [];
				var numExtraSamples = 0;
	
				if (fileDirectory.ExtraSamples) {
					extraSamplesValues = fileDirectory.ExtraSamples.values;
					numExtraSamples = extraSamplesValues.length;
				}
	
				if (fileDirectory.ColorMap) {
					var colorMapValues = fileDirectory.ColorMap.values;
					var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
				}
	
				// Loop through the strips in the image.
				for (var i = 0; i < numStrips; i++) {
					// The last strip may be short.
					if (i + 1 === numStrips) {
						numRowsInStrip = rowsInLastStrip;
					}
	
					var numPixels = strips[i].length;
					var yPadding = numRowsInPreviousStrip * i;
	
					// Loop through the rows in the strip.
					for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {
						// Loop through the pixels in the row.
						for (var x = 0; x < imageWidth; x++, j++) {
							var pixelSamples = strips[i][j];
	
							var red = 0;
							var green = 0;
							var blue = 0;
							var opacity = 1.0;
	
							if (numExtraSamples > 0) {
								for (var k = 0; k < numExtraSamples; k++) {
									if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {
										// Clamp opacity to the range [0,1].
										opacity = pixelSamples[3 + k] / 256;
	
										break;
									}
								}
							}
	
							switch (photometricInterpretation) {
								// Bilevel or Grayscale
								// WhiteIsZero
								case 0:
									if (sampleProperties[0].hasBytesPerSample) {
										var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);
									}
	
									// Invert samples.
									pixelSamples.forEach(function (sample, index, samples) {
										samples[index] = invertValue - sample;
									});
	
								// Bilevel or Grayscale
								// BlackIsZero
								case 1:
									red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
									break;
	
								// RGB Full Color
								case 2:
									red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
									green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
									blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
									break;
	
								// RGB Color Palette
								case 3:
									if (colorMapValues === undefined) {
										throw Error("Palette image missing color map");
									}
	
									var colorMapIndex = pixelSamples[0];
	
									red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
									green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
									blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
									break;
	
								// Transparency mask
								case 4:
									throw RangeError('Not Yet Implemented: Transparency mask');
									break;
	
								// CMYK
								case 5:
									throw RangeError('Not Yet Implemented: CMYK');
									break;
	
								// YCbCr
								case 6:
									throw RangeError('Not Yet Implemented: YCbCr');
									break;
	
								// CIELab
								case 8:
									throw RangeError('Not Yet Implemented: CIELab');
									break;
	
								// Unknown Photometric Interpretation
								default:
									throw RangeError('Unknown Photometric Interpretation:', photometricInterpretation);
									break;
							}
	
							ctx.fillStyle = this.makeRGBAFillValue(red, green, blue, opacity);
							ctx.fillRect(x, yPadding + y, 1, 1);
						}
					}
	
					numRowsInPreviousStrip = numRowsInStrip;
				}
			}
	
			/*		for (var i = 0, numFileDirectories = this.fileDirectories.length; i < numFileDirectories; i++) {
	  			// Stuff
	  		}*/
	
			return this.canvas;
		}
	};
	
	exports.default = TIFFParser;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = createQueryString;
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function createQueryString(params) {
	    return _.map(params, function (value, key) {
	        return encodeURIComponent(key) + '=' + encodeURIComponent(value);
	    }).join('&');
	}

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var events = function events() {
	
	    var observers = {};
	
	    return {
	        on: function on(event, callback, context) {
	            if (!observers[event]) {
	                observers[event] = [];
	            }
	            if (context) {
	                callback = callback.bind(context);
	            }
	            observers[event].push(callback);
	        },
	        fire: function fire(event, data) {
	            if (observers[event]) {
	                _.each(observers[event], function (observer) {
	                    observer(event, data);
	                });
	            }
	        }
	    };
	};
	
	exports.default = events;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	var _three = __webpack_require__(3);
	
	var _clampLineString = __webpack_require__(9);
	
	var _clampLineString2 = _interopRequireDefault(_clampLineString);
	
	var _transform = __webpack_require__(12);
	
	var _transform2 = _interopRequireDefault(_transform);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function ALine(lineGeom, style, geometry, envelope) {
	
	    var styleDefaults = {
	        color: 0x0000ff,
	        linewidth: 5
	    };
	
	    style = _.extend({}, styleDefaults, style || {});
	
	    var needsClamp = true;
	    var line;
	
	    function _createLine(points, color) {
	        var vertices = _.map(points, function (point) {
	            return new _three.Vector3(point.x, point.y, point.z);
	        });
	
	        var material = new _three.LineBasicMaterial(style);
	        var geometry = new _three.Geometry();
	        geometry.vertices = vertices;
	        return new _three.Line(geometry, material);
	    }
	
	    function getThreeLine() {
	
	        if (line) {
	            return line;
	        }
	
	        if (lineGeom.type !== 'LineString') {
	            throw new Error('Expected GeoJSON LineString geometry');
	        }
	
	        //get envelope stuff
	        var coordMinX = envelope.minX();
	        var coordMinY = envelope.minY();
	
	        //get the bbox of the geometry
	        geometry.computeBoundingBox();
	        var bbox = geometry.boundingBox;
	
	        var pixelMinX = bbox.min.x;
	        var pixelMinY = bbox.min.y;
	        var pixelWidth = Math.abs(bbox.max.x - pixelMinX);
	        var pixelHeight = Math.abs(bbox.max.y - pixelMinY);
	
	        var xFactor = envelope.width() / pixelWidth;
	        var yFactor = envelope.height() / pixelHeight;
	
	        var linedata = _.map(lineGeom.coordinates, function (coord) {
	            return (0, _transform2.default)(coord, 'EPSG:4326', envelope.mapCrs);
	        });
	
	        var points = _.map(linedata, function (coord) {
	            var x = coord[0];
	            var pixelX = pixelMinX + (x - coordMinX) / xFactor;
	            var y = coord[1];
	            var pixelY = pixelMinY + (y - coordMinY) / yFactor;
	            return { x: pixelX, y: pixelY, z: 0 };
	        });
	
	        if (geometry.loaded) {
	            points = (0, _clampLineString2.default)(points, geometry);
	        }
	        line = _createLine(points);
	
	        if (geometry.loaded) {
	            needsClamp = false;
	        }
	        return line;
	    };
	
	    function clamp() {
	        line = _createLine((0, _clampLineString2.default)(line.geometry.vertices, geometry));
	        return line;
	    }
	
	    return {
	        getThreeLine: getThreeLine,
	        clamp: clamp,
	        needsClamp: function needsClamp() {
	            return needsClamp;
	        }
	    };
	}
	
	exports.default = ALine;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(3);
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	var _checkIntersect = __webpack_require__(10);
	
	var _checkIntersect2 = _interopRequireDefault(_checkIntersect);
	
	var _lineIntersect = __webpack_require__(11);
	
	var _lineIntersect2 = _interopRequireDefault(_lineIntersect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function calcZ(p1, p2, p3, x, y) {
	    var det = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
	    var l1 = ((p2.y - p3.y) * (x - p3.x) + (p3.x - p2.x) * (y - p3.y)) / det;
	    var l2 = ((p3.y - p1.y) * (x - p3.x) + (p1.x - p3.x) * (y - p3.y)) / det;
	    var l3 = 1.0 - l1 - l2;
	    return l1 * p1.z + l2 * p2.z + l3 * p3.z;
	}
	
	function getDistance(a, b) {
	    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
	}
	
	function clampLineSegment(l, geometry) {
	    return _.chain(geometry.faces).map(function (face) {
	        var a = geometry.vertices[face.a];
	        var b = geometry.vertices[face.b];
	        var c = geometry.vertices[face.c];
	
	        var line1 = [a, b];
	        var line2 = [b, c];
	        var line3 = [c, a];
	
	        var ints = [];
	        if ((0, _checkIntersect2.default)(l, line1)) {
	            ints.push((0, _lineIntersect2.default)(line1, l));
	        }
	        if ((0, _checkIntersect2.default)(l, line2)) {
	            ints.push((0, _lineIntersect2.default)(line2, l));
	        }
	        if ((0, _checkIntersect2.default)(l, line3)) {
	            ints.push((0, _lineIntersect2.default)(line3, l));
	        }
	        return _.map(ints, function (intersect) {
	            var z = calcZ(a, b, c, intersect.x, intersect.y);
	            return {
	                x: intersect.x,
	                y: intersect.y,
	                z: z + 0.01,
	                dist: getDistance(l[0], intersect)
	            };
	        });
	    }).flatten().sortBy(function (p) {
	        return Math.abs(p.dist);
	    }).value();
	}
	
	function clampLineString(line, geometry) {
	    var p = _.map(_.range(0, line.length - 1), function (i) {
	        var a = line[i];
	        var b = line[i + 1];
	        return clampLineSegment([a, b], geometry);
	    });
	    return _.flatten(p);
	}
	
	exports.default = clampLineString;

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// Given three colinear points p, q, r, the function checks if
	// point q lies on line segment 'pr'
	function onSegment(p, q, r) {
	    if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) {
	        return true;
	    }
	    return false;
	}
	
	// To find orientation of ordered triplet (p, q, r).
	// The function returns following values
	// 0 --> p, q and r are colinear
	// 1 --> Clockwise
	// 2 --> Counterclockwise
	function orientation(p, q, r) {
	    // See http://www.geeksforgeeks.org/orientation-3-ordered-points/
	    // for details of below formula.
	    var val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	
	    if (val === 0) {
	        return 0; // colinear
	    }
	    return val > 0 ? 1 : 2; // clock or counterclock wise
	}
	
	// The main function that returns true if line segment 'p1q1'
	// and 'p2q2' intersect.
	function checkIntersect2(l1, l2) {
	
	    var p1 = l1[0];
	    var p2 = l1[1];
	
	    var q1 = l2[0];
	    var q2 = l2[1];
	
	    // Find the four orientations needed for general and
	    // special cases
	    var o1 = orientation(p1, q1, p2);
	    var o2 = orientation(p1, q1, q2);
	    var o3 = orientation(p2, q2, p1);
	    var o4 = orientation(p2, q2, q1);
	    // General case
	    if (o1 !== o2 && o3 !== o4) {
	        return true;
	    }
	
	    // Special Cases
	    // p1, q1 and p2 are colinear and p2 lies on segment p1q1
	    if (o1 === 0 && onSegment(p1, p2, q1)) {
	        return true;
	    };
	
	    // p1, q1 and p2 are colinear and q2 lies on segment p1q1
	    if (o2 === 0 && onSegment(p1, q2, q1)) {
	        return true;
	    }
	
	    // p2, q2 and p1 are colinear and p1 lies on segment p2q2
	    if (o3 === 0 && onSegment(p2, p1, q2)) {
	        return true;
	    }
	    // p2, q2 and q1 are colinear and q1 lies on segment p2q2
	    if (o4 === 0 && onSegment(p2, q1, q2)) {
	        return true;
	    }
	
	    return false; // Doesn't fall in any of the above cases
	}
	
	function Turn(p1, p2, p3) {
	    var a = p1.x;
	    var b = p1.y;
	    var c = p2.x;
	    var d = p2.y;
	    var e = p3.x;
	    var f = p3.y;
	    var A = (f - b) * (c - a);
	    var B = (d - b) * (e - a);
	    return A > B + Number.EPSILON ? 1 : A + Number.EPSILON < B ? -1 : 0;
	}
	
	function checkIntersect(l1, l2) {
	    var p1 = l1[0];
	    var p2 = l1[1];
	    var p3 = l2[0];
	    var p4 = l2[1];
	    return Turn(p1, p3, p4) !== Turn(p2, p3, p4) && Turn(p1, p2, p3) !== Turn(p1, p2, p4);
	}
	
	exports.default = checkIntersect;

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = lineIntersect;
	function lineIntersect(l1, l2) {
	    var x1 = l1[0].x;
	    var y1 = l1[0].y;
	
	    var x2 = l1[1].x;
	    var y2 = l1[1].y;
	
	    var x3 = l2[0].x;
	    var y3 = l2[0].y;
	
	    var x4 = l2[1].x;
	    var y4 = l2[1].y;
	    var ua,
	        ub,
	        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	    if (denom === 0) {
	        return null;
	    }
	    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
	    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
	    return {
	        x: x1 + ua * (x2 - x1),
	        y: y1 + ua * (y2 - y1),
	        z: 0
	    };
	}

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = transform;
	
	var _index = __webpack_require__(13);
	
	var _index2 = _interopRequireDefault(_index);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_index2.default.defs('EPSG:32632', '+title=EPSG Projection 32632 - WGS 84 / UTM zone 32N +proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs');
	_index2.default.defs('EPSG:32633', '+title=EPSG Projection 32633 - WGS 84 / UTM zone 33N +proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs');
	
	function transform(coord, from, to) {
	    return (0, _index2.default)(from, to, coord);
	}

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = proj4;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(3);
	
	var _createQueryString = __webpack_require__(6);
	
	var _createQueryString2 = _interopRequireDefault(_createQueryString);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function Texture(textureConfig, dim) {
	
	    function _getImageMap() {
	        var imageCall;
	        if (textureConfig.imgUrl) {
	            //IMAGE
	            return textureConfig.imgUrl;
	        }
	        var params = {
	            service: 'wms',
	            version: '1.3.0',
	            request: 'getMap',
	            crs: dim.crs,
	            WIDTH: dim.imgWidth,
	            HEIGHT: dim.imgHeight,
	            bbox: dim.envelope.bbox(),
	            layers: textureConfig.wmsLayers,
	            format: textureConfig.wmsFormat + textureConfig.wmsFormatMode
	        };
	        return textureConfig.wmsUrl + '?' + (0, _createQueryString2.default)(params);
	    };
	
	    function loadTexture(material, callback) {
	        var loader = new _three.TextureLoader(),
	            image = _getImageMap();
	        // load a resource
	        loader.load(image, function (texture) {
	            //Texture is probably not the power of two.
	            //Avoid warning: Apply THREE.LinearFilter or THREE.NearestFilter
	            texture.minFilter = _three.LinearFilter;
	            material.map = texture;
	            material.needsUpdate = true;
	            if (callback) {
	                callback(texture);
	            }
	        },
	        // Function called when download progresses
	        function (xhr) {},
	        // Function called when download errors
	        function (xhr) {
	            console.log('An error happened on texture load: ' + image);
	        });
	    };
	    return {
	        loadTexture: loadTexture
	    };
	}
	
	exports.default = Texture;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(3);
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	var _tiff = __webpack_require__(5);
	
	var _tiff2 = _interopRequireDefault(_tiff);
	
	var _createQueryString = __webpack_require__(6);
	
	var _createQueryString2 = _interopRequireDefault(_createQueryString);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var Terrain = function Terrain(terrainConfig, dim) {
	
	    var isTiff = terrainConfig.format === 'geotiff';
	    var geometry;
	    var _minHeight, _midHeight;
	
	    function _getTiffHeights(xhr) {
	        var tiffParser = new _tiff2.default();
	        var tiffArray = tiffParser.parseTIFF(xhr.response);
	        var i = -1;
	        var heights = [];
	        for (var j = 0; j < tiffArray.length; j++) {
	            for (var k = 0; k < tiffArray[j].length; k++) {
	                heights.push(parseInt(tiffArray[j][k][0], 10));
	            }
	        }
	        return heights;
	    }
	
	    function _getXYZHeights(xhr) {
	        var numVertices = geometry.vertices.length;
	        var lines = xhr.responseText.split('\n');
	        var heights = [];
	        for (var i = 0, l = numVertices; i < l; i++) {
	            heights[i] = parseInt(lines[i].split(' ')[2], 10);
	        }
	        return heights;
	    }
	
	    function _parseHeights(xhr) {
	
	        var heights = isTiff ? _getTiffHeights(xhr) : _getXYZHeights(xhr);
	
	        var minHeight = _.min(heights);
	        var maxHeight = _.max(heights);
	
	        //The Vertical center of the height model is adjusted to (min + max) / 2.
	        //If the map covers an area of high altitudes (i.e. Galdhpiggen) above sea level,
	        //a tipping of the model will cause the map to disappear over the screen top without this
	        //adjustment.
	        //On a computer you can move the model down width a right-click-drag,
	        //but not on a mobile device.
	        var midHeight = (maxHeight + minHeight) / 2;
	
	        return {
	            height: heights,
	            midHeight: midHeight,
	            minHeight: (minHeight - midHeight) / dim.zMult
	        };
	    };
	
	    function _createGeometry() {
	        geometry = new _three.PlaneGeometry(dim.demWidth, dim.demHeight, dim.demWidth - 1, dim.demHeight - 1);
	    };
	
	    function _terrainLoaded(data) {
	        for (var i = 0, l = geometry.vertices.length; i < l; i++) {
	            geometry.vertices[i].z = (data.height[i] - data.midHeight) / dim.zMult;
	        }
	        geometry.loaded = true;
	        geometry.verticesNeedUpdate = true;
	        _minHeight = data.minHeight;
	        _midHeight = data.midHeight;
	    }
	
	    function loadTerrain(callback) {
	        var demRequest = new XMLHttpRequest();
	
	        var params = {
	            SERVICE: 'WCS',
	            VERSION: '1.0.0',
	            REQUEST: 'GetCoverage',
	            COVERAGE: terrainConfig.coverage,
	            FORMAT: terrainConfig.format,
	            bbox: dim.envelope.bbox(),
	            CRS: dim.crs,
	            RESPONSE_CRS: dim.crs,
	            WIDTH: dim.demWidth,
	            HEIGHT: dim.demHeight
	        };
	
	        var wcsCall = terrainConfig.wcsUrl + '?' + (0, _createQueryString2.default)(params);
	        if (isTiff) {
	            demRequest.responseType = 'arraybuffer';
	        }
	        demRequest.open('GET', wcsCall, true);
	        demRequest.onreadystatechange = function () {
	            if (this.readyState === 4) {
	                _terrainLoaded(_parseHeights(this));
	                callback();
	            }
	        };
	        demRequest.send();
	    };
	
	    function _createSideMesh(filter) {
	        var points = _.chain(geometry.vertices).filter(filter).map(function (vertex) {
	            return [new _three.Vector3(vertex.x, vertex.y, vertex.z), new _three.Vector3(vertex.x, vertex.y, _minHeight)];
	        }).flatten().value();
	        var first = _.first(points).clone();
	        var last = _.last(points).clone();
	        first.z = _minHeight;
	        last.z = _minHeight;
	
	        var sideGeometry = new _three.Geometry();
	        points.unshift(first);
	        points.push(last);
	
	        var faces = _.map(_.range(1, points.length - 1), function (i) {
	            return new _three.Face3(i - 1, i, i + 1);
	        });
	
	        sideGeometry.vertices = points;
	        sideGeometry.faces = faces;
	        return new _three.Mesh(sideGeometry, new _three.MeshBasicMaterial({
	            side: _three.DoubleSide,
	            color: terrainConfig.boxColor,
	            wireframe: false
	        }));
	    }
	
	    function getSides() {
	        if (!terrainConfig.showBox) {
	            return null;
	        }
	        var material = new _three.MeshBasicMaterial({
	            wireframe: false,
	            color: terrainConfig.boxColor,
	            side: _three.BackSide
	        });
	
	        var backGeom = new _three.PlaneGeometry(dim.demWidth, dim.demHeight, dim.demWidth - 1, dim.demHeight - 1);
	
	        for (var i = 0, l = backGeom.vertices.length; i < l; i++) {
	            backGeom.vertices[i].z = _minHeight;
	        }
	
	        var group = new _three.Group();
	        group.add(new _three.Mesh(backGeom, material));
	
	        geometry.computeBoundingBox();
	        var bbox = geometry.boundingBox;
	
	        var filterLeft = function filterLeft(vertex) {
	            return vertex.x === bbox.min.x;
	        };
	
	        var filterBottom = function filterBottom(vertex) {
	            return vertex.y === bbox.min.y;
	        };
	
	        var filterRight = function filterRight(vertex) {
	            return vertex.x === bbox.max.x;
	        };
	
	        var filterTop = function filterTop(vertex) {
	            return vertex.y === bbox.max.y;
	        };
	
	        group.add(_createSideMesh(filterBottom));
	        group.add(_createSideMesh(filterRight));
	        group.add(_createSideMesh(filterLeft));
	        group.add(_createSideMesh(filterTop));
	        return group;
	    }
	
	    _createGeometry();
	
	    return {
	        loadTerrain: loadTerrain,
	        getGeometry: function getGeometry() {
	            return geometry;
	        },
	        minHeight: function minHeight() {
	            return _minHeight;
	        },
	        midHeight: function midHeight() {
	            return _midHeight;
	        },
	        getSides: getSides,
	
	        showBox: terrainConfig.showBox
	    };
	};
	
	exports.default = Terrain;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	var _three = __webpack_require__(3);
	
	var _Texture = __webpack_require__(14);
	
	var _Texture2 = _interopRequireDefault(_Texture);
	
	var _transform = __webpack_require__(12);
	
	var _transform2 = _interopRequireDefault(_transform);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function Profiles(profiles, terrain, dim) {
	
	    function _transformPoint(sSource, sDest, x, y) {
	        if (typeof x === 'string') {
	            x = 1.0 * x;
	            y = 1.0 * y;
	        }
	        return (0, _transform2.default)([x, y], sSource, sDest);
	    };
	
	    function _createProfile(profile, config) {
	        var verticalGeometry = new _three.PlaneGeometry(1, 1);
	        var verticalMaterial = new _three.MeshPhongMaterial({
	            side: _three.DoubleSide,
	            transparent: true
	        });
	        var crsSource = profile.CRS;
	
	        //Check and transform to another map projection
	
	        if (crsSource !== config.crsDestination) {
	            var pointStart = _transformPoint(crsSource, config.crsDestination, profile.xyStart.x, profile.xyStart.y),
	                pointEnd = _transformPoint(crsSource, config.crsDestination, profile.xyEnd.x, profile.xyEnd.y);
	            profile.xyStart.x = pointStart[0];
	            profile.xyStart.y = pointStart[1];
	            profile.xyEnd.x = pointEnd[0];
	            profile.xyEnd.y = pointEnd[1];
	        }
	
	        //Local transformation
	        var newStartX = config.kX * profile.xyStart.x - config.kX * dim.envelope.minX() - dim.demWidth / 2,
	            newStartY = config.kY * profile.xyStart.y - config.kY * dim.envelope.minY() - dim.demHeight / 2,
	            newEndX = config.kX * profile.xyEnd.x - config.kX * dim.envelope.minX() - dim.demWidth / 2,
	            newEndY = config.kY * profile.xyEnd.y - config.kY * dim.envelope.minY() - dim.demHeight / 2,
	            newStartZ = profile.zStart - terrain.midHeight(),
	            newEndZ = profile.zEnd - terrain.midHeight(),
	            verticalMesh = new _three.Mesh(verticalGeometry, verticalMaterial);
	
	        //XY
	        verticalMesh.geometry.vertices[0].x = newStartX;
	        verticalMesh.geometry.vertices[0].y = newStartY;
	        verticalMesh.geometry.vertices[1].x = newEndX;
	        verticalMesh.geometry.vertices[1].y = newEndY;
	        verticalMesh.geometry.vertices[2].x = newStartX;
	        verticalMesh.geometry.vertices[2].y = newStartY;
	        verticalMesh.geometry.vertices[3].x = newEndX;
	        verticalMesh.geometry.vertices[3].y = newEndY;
	
	        //Z
	        profile.zStart - terrain.midHeight();
	        verticalMesh.geometry.vertices[0].z = newStartZ / dim.zMult; //900/zMult;
	        verticalMesh.geometry.vertices[1].z = newStartZ / dim.zMult; //900/zMult;//
	        verticalMesh.geometry.vertices[2].z = newEndZ / dim.zMult; //-1406/zMult;
	        verticalMesh.geometry.vertices[3].z = newEndZ / dim.zMult; //-1406/zMult;
	
	
	        var texture = (0, _Texture2.default)({
	            type: 'image',
	            imgUrl: profile.imgUrl
	        }, null);
	        texture.loadTexture(verticalMaterial);
	
	        return verticalMesh;
	    }
	
	    function load(callback) {
	        //json response for profile metadata db query
	        var geometry = terrain.getGeometry();
	        var modelLL = geometry.vertices[geometry.vertices.length - dim.demWidth];
	        var modelUR = geometry.vertices[dim.demWidth - 1];
	        var data = {
	            crsDestination: dim.crs,
	            kX: (modelUR.x - modelLL.x) / dim.envelope.width(),
	            kY: (modelUR.y - modelLL.y) / dim.envelope.height()
	        };
	
	        var meshes = _.map(profiles, function (profile) {
	            return _createProfile(profile, data);
	        });
	
	        callback(meshes);
	    }
	
	    return {
	        load: load
	    };
	}
	
	exports.default = Profiles;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = Envelope;
	
	var _underscore = __webpack_require__(1);
	
	var _ = _interopRequireWildcard(_underscore);
	
	var _transform = __webpack_require__(12);
	
	var _transform2 = _interopRequireDefault(_transform);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function Envelope(bbox, crs, bboxCrs) {
	    var bbox = _.map(bbox.split(','), parseFloat);
	    var ne = [bbox[0], bbox[1]];
	    var sw = [bbox[2], bbox[3]];
	    if (crs !== bboxCrs) {
	        ne = (0, _transform2.default)(ne, bboxCrs, crs);
	        sw = (0, _transform2.default)(sw, bboxCrs, crs);
	    }
	
	    var envelope = ne.concat(sw);
	
	    function width() {
	        return envelope[2] - envelope[0];
	    }
	
	    function height() {
	        return envelope[3] - envelope[1];
	    }
	
	    function getBbox() {
	        return envelope.join(',');
	    }
	
	    function minX() {
	        return envelope[0];
	    }
	
	    function minY() {
	        return envelope[1];
	    }
	
	    return {
	        width: width,
	        height: height,
	        bbox: getBbox,
	        minX: minX,
	        minY: minY,
	        mapCrs: crs
	    };
	}

/***/ }
/******/ ]);
//# sourceMappingURL=Wxs3Map.min.js.map